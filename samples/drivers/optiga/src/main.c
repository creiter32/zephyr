/*
 * Copyright (c) 2018 Savoir-Faire Linux.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <device.h>
#include <errno.h>
#include <sys/util.h>
#include <zephyr.h>
#include "cmds_trust_x.h"
#include "helpers.h"

#define LOG_LEVEL CONFIG_LOG_DEFAULT_LEVEL
#include <logging/log.h>
LOG_MODULE_REGISTER(main);
struct device *dev = NULL;

#define TMP_BUF_SIZE 1024
static u8_t tmp_buf[TMP_BUF_SIZE] = {0};
static size_t tmp_buf_len = TMP_BUF_SIZE;

void read_status()
{
	u8_t status_reg[4] = {0};
	int res = optiga_reg_read(dev, 0x82, status_reg, 4);

	if (res != 0) {
		LOG_INF("Failed to read status register");
		return;
	}

	LOG_HEXDUMP_INF(status_reg, 4, "Read status register:");
}

u8_t res_buf[900] = {0};
size_t res_len = 900;

const size_t test_data_len = 512;
const u8_t test_data[512] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, /* 16 bytes data */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0xEF, /* 16 bytes data */
													/* 512 bytes total */
	};


void main(void)
{
	LOG_INF("Hello OPTIGA");
	dev = device_get_binding("trust-m");

	if (dev == NULL) {
		LOG_INF("Could not get Trust M device\n");
		return;
	}

	LOG_INF("Found Trust M device");

	run_tests();

	struct cmds_ctx ctx;

	int res = cmds_trust_x_init(&ctx, dev, tmp_buf, TMP_BUF_SIZE);

	LOG_INF("cmds_trust_x_init res: %d", res);

	/* test small reads */
	res_len = 16;
	res = cmds_trust_x_get_data_object(&ctx, 0xE0E0, 0, res_buf, &res_len);

	LOG_INF("cmds_trust_x_get_data_object res: %d", res);
	LOG_HEXDUMP_INF(res_buf, res_len, "Get DO small:");

	/* read device certificate */
	res_len = 900;
	res = cmds_trust_x_get_data_object(&ctx, 0xE0E0, 0, res_buf, &res_len);

	LOG_INF("cmds_trust_x_get_data_object res: %d", res);
	LOG_HEXDUMP_INF(res_buf, res_len, "Get DO:");


	k_sleep(100);

	/* write device certificate without TLS header */
	res = cmds_trust_x_set_data_object(&ctx, 0xE0E1, 0, res_buf + 9, res_len - 9);
	LOG_INF("cmds_trust_x_set_data_object res: %d", res);
	k_sleep(100);

	res_len = 900;
	res = cmds_trust_x_get_data_object(&ctx, 0xE0E1, 0, res_buf, &res_len);

	LOG_INF("cmds_trust_x_get_data_object res: %d", res);
	LOG_HEXDUMP_INF(res_buf, res_len, "Get DO:");

	u8_t digest[32] = {0};
	u8_t signature[CMDS_TRUSTX_NIST_P256_SIGNATURE_LEN] = {0};

	s64_t time_stamp = k_uptime_get();
	res = cmds_trust_x_sign_ecdsa(&ctx, 0xE0F0, digest, 32, signature, CMDS_TRUSTX_NIST_P256_SIGNATURE_LEN);
	s32_t milliseconds_spent = k_uptime_delta(&time_stamp);

	LOG_INF("cmds_trust_x_sign_ecdsa res: %d, %d ms", res, milliseconds_spent);
	LOG_HEXDUMP_INF(signature, CMDS_TRUSTX_NIST_P256_SIGNATURE_LEN, "Signature:");

	k_sleep(100);

	time_stamp = k_uptime_get();
	res = cmds_trust_x_verify_ecdsa_oid(&ctx, 0xE0E1, digest, 32, signature, CMDS_TRUSTX_NIST_P256_SIGNATURE_LEN);
	milliseconds_spent = k_uptime_delta(&time_stamp);

	LOG_INF("cmds_trust_x_verify_ecdsa_oid res: %d, %d ms", res, milliseconds_spent);
	if(res == 0) {
		LOG_INF("VERIFY OK");
	} else {
		LOG_INF("VERIFY FAIL");
	}

	u8_t pub_key[CMDS_TRUSTX_NIST_P256_PUB_KEY_LEN] = {0};
	size_t pub_key_len = CMDS_TRUSTX_NIST_P256_PUB_KEY_LEN;

	time_stamp = k_uptime_get();
	res = cmds_trust_x_gen_key_ecdsa(&ctx, 0xE100, CMDS_TRUSTX_ALGORITHM_NIST_P256, CMDS_TRUSTX_KEY_USAGE_FLAG_SIGN, pub_key, &pub_key_len);
	milliseconds_spent = k_uptime_delta(&time_stamp);
	LOG_INF("cmds_trust_x_gen_key_ecdsa res: %d, %d ms", res, milliseconds_spent);
	LOG_HEXDUMP_INF(pub_key, CMDS_TRUSTX_NIST_P256_PUB_KEY_LEN, "Pub Key:");

	while(true) {
		read_status();
		k_sleep(1000);
	}
}
